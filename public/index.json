[
{
	"uri": "/100_architectural-observability/40_observation/1_config_obs.html",
	"title": "Config Observation",
	"tags": [],
	"description": "",
	"content": "\nSetting up automatic observation of architectural changes Click on the OBSERVATION page. The first page (figure below) is used to configure which events should be triggered due to differences between the new measurement (auto learning) and the baseline. You can set the exclusivity threshold for the domain exclusivity event and you can enable to get mail and slack notifications when an automatic learning ends.\nLeave the Configure Alerts unchanged and click Configure Plan. Select \u0026ldquo;Baseline 1\u0026rdquo; as the base measurement - the events will be triggered by comparing the new measurement with \u0026ldquo;Baseline 1\u0026rdquo;. You can optionally enable triggering starting and ending learning via scripts (useful for automatic learning as part of CI/CD pipelines) but we are not be covering that in this tutorial.\nClick on Schedule Learning and then on Add New Schedule. This page is used to time starting and ending of learning (note the server current time at the top right corner of the page). You must select the controllers for the learning. The Repeat sets the frequency of the learning (e.g., daily) while the Analysis can be set to a lower frequency (e.g., Weekly). Having a lower frequency of analysis means that the learning can continue to add data to the same measurement but only when the analysis will performed the new measurement events will be triggered and the measurement will become accessible for the user to review. In our case, we only have one controller - oms-controller.\nWe will configure and use schedule learning later - for now you can simply continue to the next page.\n![Config Plan](/images/ConfigSchedLearning.png) "
},
{
	"uri": "/100_architectural-observability/30_analysis/1_import_baseline.html",
	"title": "Importing measurements",
	"tags": [],
	"description": "",
	"content": "\nImporting the starting point measurement Every measurement may have different results following the Learning Phase, depending on the flows covered in the original application. Since this is a step-by-step tutorial, it is recommended to start by importing the measurement used for the analysis steps in this tutorial.\nGo to the vFunction Server Web UI\nSwitch to the Analysis page\nClick MEASUREMENTS (bottom of the pane), select IMPORT MEASUREMENT and then CHOOSE FILE in the popup dialog\nIn the Open file dialog, select C:\\vFunctionLab\\measurements\\Analysis-Tutorial-Start.zip and click Open\nClick IMPORT\nThe initial measurement should load after a few seconds.\nClick on the bell shaped icon at the top of the page to see the notifications - you should have a notification that the learning results include beans and database tables.\nClick Configure Parameters under ACTIONS in the left pane, and ensure the checkmark Enable Auto Refactoring is checked (turned on)\n"
},
{
	"uri": "/",
	"title": "vFunction Workshop",
	"tags": [],
	"description": "",
	"content": "\nvFunction AWS Workshop Introduction vFunction is an Architectural Observability and Automation platform for architects to manage software architectural technical debt and enable continuous application modernization.\nThe vFunction platform has two modules:\nArchitectural Observability (AO): for analyzing the applications and continuously monitor and handle architectural debt and drifts\nRefactoring Engine (RE): automation to create services corresponding to the functional domains specified in the AO module as independent software components.\nHow to do this Workshop? Start by setting up your environment by completing the Setup Environment section.\nThen do the AO Tutorial - a hands-on tutorial for the Architectural Observability module\nIf you are interested extracting services corresponding to the domains specified in the AO Module, do the RE Tutorial.\nTo delete the resources created in the setup, make sure to do the Cleanup section when you\u0026rsquo;re done.\nTo flip pages use the right and left arrows at the sides of the main frame.\nUse the left frame for content navigation and search.\nTo benefit the most from this workshop, you should know: Basic Java (we will use Eclipse for coding). Basic UNIX commands. Basic AWS concepts. "
},
{
	"uri": "/100_architectural-observability/30_analysis/2_analysis_page.html",
	"title": "Analysis page walkthrough",
	"tags": [],
	"description": "",
	"content": "\nAnalysis page walkthrough Let\u0026rsquo;s walk through the analysis page and understand the basics.\nThe center pane shows spheres representing the domains. The sphere\u0026rsquo;s size is proportional to the number of classes it includes. The color represents its exclusivity – the percentage of classes that are only used by the domain itself (exclusive to the domain). We will elaborate more on exclusivity later. The dashed arrows between spheres represent calls across domains. The calls can be seen when hovering over the arrows.\nAt the top of the center pane, we see four hyperlinks to navigate between the phases (Learning, Analysis, Observation and Service Creation). Every time a change is made to the domains during the analysis, the blue line under the Analysis label will show the progress of the auto-analysis run.\nThe magnifying glass icon at the top right is used for doing a string-based search.\nNext to the search we have a bell icon with a number showing a number. This icon is used to open notification for the user and number is the number of notifications. Currently, if you click on this icon you should see one notification that the learning results include beans and DB tables.\nAt the bottom of the central pane, there is a menu labeled MEASUREMENTS which has various actions related to measurements such as selecting, importing, downloading, creating a snapshot, etc.\nThe left pane has several sections:\nAnalysis Output: provides a summary of the current analysis status, such as the total no. of domains, entry points, etc., and a summary of the total exclusivity measure of the domains.\nActions: a set of actions concerning the entire analysis, for example, configuring the analysis parameters, showing resource report, etc.\nA legend that includes a histogram showing the number of domains for each level of exclusivity.\nThe right pane lists all the domains. It has a filter field at the top to filter domains by name. Selecting a domain in the list also selects the corresponding sphere (and vice versa). Hovering over a sphere in the center pane will highlight the domain on the right pane.\nAlso on the right pane, there is a second tab labeled \u0026ldquo;High Debt\u0026rdquo; where architecturally high-debt classes are listed. In our case, OMS is a very simple application, so if you click on that tab you will just see ProductController, and even this class has a debt score of 3.1 out of 10.\n"
},
{
	"uri": "/100_architectural-observability/30_analysis/2.1-oms_jars.html",
	"title": "Reviewing the OMS Jars",
	"tags": [],
	"description": "",
	"content": "\nThe OMS Jars You can view the various jar files of your application and their inter dependencies in vFunction. This allows you to determine if some of the jars of your application should be marked as infra jars.\nAn infra jar is jar library which is part of the current application that will continue to be used as a library in the new architecture by the domains. Marking a jar as infra reduces the scope of the analysis and will result in dependencies from the domains build files to infra jars that are required by each of the domains. Typically, infra jars are general purpose libraries that are not part of any of the functional/business domains provided by the domains.\nThe OMS application is deployed as a war file in Apache Tomcat. To view the jars and their dependencies click Configure Parameters under ACTIONS in the left pane of the analysis page. Then, click on the graph icon above the Infra Jars field (circled in red below)\nYou should see a graph similar to the screenshot below. As seen in the screenshot, hovering over a line lists the compile time dependencies of the classes across the jars. Solid lines represent the existence of compile time dependencies across classes and dashed lines represent classes that are loaded via reflection (not present in the OMS example)\nThe right pane lists the various jar files - there are zero INFRA jars and six NON (Infra) jars.\nClicking DETAILS under a jar will open the graph for this jar in the main pane. The entry classes represents the set of classes that not part of any jar.\nYou can also click on a jar on the graph to see it dependencies and dependents.\nFinally, vFunction will not permit marking a jar as Infra if it has dependencies to classes in the domains (non-infra jars). If you switch back to the Configure Parameters window, you will see a green dot indicating if the current infra jar list is OK (as there are no infra jars). If you try to add the oms-dal jar to the list, the dot will turn red indicating this jar can not be made infra and you won\u0026rsquo;t be able to do SUBMIT. If you switch to the jar graph of oms-dal, click on it and do \u0026ldquo;MARK JAR AS INFRA\u0026rdquo; a verification dialog will open notifying that this will also mandate the oms-model jar to become infra.\nLet\u0026rsquo;s leave the list of infra jars empty and continue.\n"
},
{
	"uri": "/100_architectural-observability/40_observation/2_update_app.html",
	"title": "Update OMS",
	"tags": [],
	"description": "",
	"content": "\nChange the OMS Application In this section we will clone the OMS public git repo, switch to the updated branch and then configure and deploy the new version.\nThe modified version of OMS adds managing customers.\nAll the commands are done on the Linux machine, i.e., open PuTTY as you\u0026rsquo;ve done in the Setup Environment section and login to the Linux VM.\nInstall git sudo yum install git Install maven sudo yum install maven Clone code repo and checkout ao-demo-1 branch cd ~ git clone https://workshop@bitbucket.org/vfunction/oms-tutorial.git cd oms-tutorial git checkout ao-demo-1 Update the DB properties cd ~/oms-tutorial/oms-webmvc sudo cp /opt/tomcat/latest/webapps/oms-0.0.1-SNAPSHOT/META-INF/context.xml ./app/src/main/webapp/META-INF/context.xml Build the app cd ~/oms-tutorial/oms-webmvc mvn install Deploy the application sudo cp ./app/target/oms-0.0.1-SNAPSHOT.war /opt/tomcat/latest/webapps/ Restart tomcat sudo /opt/tomcat/latest/bin/shutdown.sh sudo /opt/tomcat/latest/bin/startup.sh Since the binaries changed, we need to restart the controller in order to restart viper (the process doing static analysis), otherwise vFunction will notify that static analysis is missing classes and the architecture will be incorrect. sudo cd /opt/vfunction/controller-installation sudo bash restart-controller.sh "
},
{
	"uri": "/100_architectural-observability/30_analysis/3_order_controller.html",
	"title": "Order Controller",
	"tags": [],
	"description": "",
	"content": "\nOrder Controller In this section, we will focus on the OrderController domain:\nClick on the OrderController domain on the right pane. The names of the domains are derived from the classes that own the end points through which clients access the domain. These endpoints are called entry points.\nThe domain has three entry points. To review them, click EXPLORE TREE next to the Entry Points of the OrderController domain. On the left pane, you see the three endpoints. In the center pane, you see the call tree provided by the dynamic analysis. Clicking the left-most arrow in the call tree will take you up the tree, meaning it shows the calling nodes.\nViewing the Entry Points and their calltree of OrderController domain Click on Back to domains. The dynamic class exclusivity is 100% - this means that the classes identified by the dynamic analysis flows are used exclusively by this domain. Click VIEW next to the Dynamic classes. You will see two exclusive classes (OrderController and OrderService), 0 non-exclusive classes (classes used by other domains), and 1 Common class (Logger). Common classes are classes marked to be included in a jar used by all domains as a library. We name this jar common jar.\nClick Back to domains – the static class exclusivity is 20%. Click on VIEW next to it. We see two exclusive classes and 8 non-exclusive classes, hence the 20% value (2 out of 10).\nClick on the NON filter to view the non-exclusive classes. Click on the BillToAddress class - it belongs to the package com.oms.entity, which contains the @Entity classes that correspond to the database. We will add all the entity classes into the common jar. This is of course a design decision, and one may decide to try and add only the relevant entities to each domain. Click MARK PACKAGE AS COMMON, leave the package name as com.oms.entity, and click SUBMIT. The analysis will automatically re-run, and we will remain with a single non-exclusive class – SalesOrderRepository.\nAfter the analysis is complete, click SalesOrderRepository and then on the class DETAILS (next to Not exclusive to domain). You will see that this class is being used by two domains: OrderController and ModifyFulfillmentController. Click on OrderController - a graph like the one below appears in the center pane. It shows that the class Orderdomain is referencing SalesOrderRepository as a bean (dashed arrow), and it is referencing SalesOrder as a compile-time dependency (solid arrow). Also, SalesOrderRepository references SalesOrder.\nStatic Dependencies of SalesOrderRepository Click again on Details of SalesOrderRepository, but now select ModifyFulfillmentController to see how that domain references the SalesOrderRepository class. You will see a similar usage.\nSince SalesOrderRepository is a JPA repository used only by these two domains (OrderController and ModifyFulfillmentController), keep this class non-exclusive in the analysis. This means the class will be duplicated into both domains.\nGo back to the domains list and open click VIEW next to Order Controller Resources. Resources are external virtual or physical objects used by the domains such as database tables, files, transactions, spring beans, network sockets, and more. OrderController has ten exclusive resources (The resource used exclusively by this domain) and eight non-exclusive resources (resources shared with other domains).\nClick on the NON filter to view the non-exclusive resources. You can see a list of database tables used by the Order Controller domain, which are shared by others. Click Details on a table to see which other domains use it.\nAt the bottom of the list, you see a file resource (oms-log.txt). Clicking Details will show that many domains write to this file. Mark this file as common to indicate that this resource is shared across all domains and should not affect resource exclusivity.\nClick Back to domains\n"
},
{
	"uri": "/100_architectural-observability/40_observation/3_sched_learning.html",
	"title": "Scheduled Learning",
	"tags": [],
	"description": "",
	"content": "\nSimulating scheduled learning with the modified OMS app Go to the vFunction Web UI and open the Observation page\nAdd a new schedule for learning\nSet the controller to oms-controller\nSet the Repeat and the Analysis schedule to daily\nSet the time slot to 5 min. before the current server time and 10 min. length (e.g., if the current server time is 2:00 PM, set it to 1:55 PM - 2:05 PM)\nSwitch to the terminal of the Linux and run the script in a loop:\ncd ~/oms-tutorial/oms-webmvc/script for i in `seq 1000`; do ./use-apis.sh ; sleep 0.5; done In the vFunction server web ui you should see the schedule learning is active - a rotating arrow next to the schedule name under the schedules section (bottom right). Wait for the learning to complete. You can also switch to the Learning page and see the controller state by clicking Select Controllers (under ACTIONS)\nAfter the learning is done, it will take a minute or two for the analysis to complete and then you should have a new measurement to Select starting with Scheduled (MEASUREMENT-\u0026gt;SELECT MEASUREMENT at the bottom of the analysis page)\n"
},
{
	"uri": "/100_architectural-observability/30_analysis/4_inventory_controller.html",
	"title": "Inventory Controller",
	"tags": [],
	"description": "",
	"content": "\nInventory Controller Moving on to the InventoryController domain\nIn the domains view of the analysis page, locate and open InventoryController\nClick VIEW next to Dynamic classes to review the dynamic analysis results. There are two exclusive classes and one non-exclusive class (InventoryService)\nClick on Details of the non-exclusive InventoryService class. You can see that ProductController is also using it.\nScroll down in the Details popup and click on ProductService.getProductInventory(), the call tree will open as shown as below:\nProduct Domain calling the InventoryService class The call tree shows the ProductController is calling the InventoryService class, which is the service class of InventoryController domain. Technically we can either merge the two domains into one domain (we will do this later for the Payment domains, or we can create a new entry point in InventoryController for ProductController to access as a client. Since both domains represent distinct functional domains, we will choose the second option.\nIn the call tree, hover over the InventoryService$$EnhancerBySpringCGLIB.fetchInventory() node, click MAKE ENTRY POINT, then METHOD, check InventoryController and click MAKE.\nCreating an Entry Point in the call tree Click Back to domains. The InventoryController service should be completely exclusive (including static and resources) "
},
{
	"uri": "/100_architectural-observability/40_observation/4_review_results.html",
	"title": "Review Results",
	"tags": [],
	"description": "",
	"content": "\nReview scheduled learning and anlysis results Go to the vFunction Web UI and switch to the analysis page\nFrom the MEASUREMENT menu (bottom of page) SELECT the Scheduled measurement\nClick on the Bell icon at the top of the page to see the notifications - it should look like the following:\nLet\u0026rsquo;s review the notifications:\nNotification that the scheduled learning was done and the data was sent to analysis A new class was introduced to the common library: com.oms.entity.Customer A new CustomerController domain was added Since we have a new domain that was introduced (which is correct) can proceed and review the analysis and set the new measurement as a new baseline.\nRename the measurement as Baseline 2 and then mark Baseline 2 as the main measurement via the SELECT MEASUREMENT menu. You can optionally clean all notifications.\nSwitch to the Observation page and change Baseline 2 to become new baseline measurement\n"
},
{
	"uri": "/100_architectural-observability/30_analysis/5_product_controller.html",
	"title": "Product Controller",
	"tags": [],
	"description": "",
	"content": "\nProduct Controller Select the ProductController domain; notice that its sphere has an arrow pointing to the InventoryController domain because of the entry point we added in the previous section. Hovering over that line shows the method we marked as the new entry point. The Dynamic exclusivity of ProductController is already 100%.\nLet’s view the static analysis result as we did before. The two non-exclusive classes are ShippingRepository and ShippingService.\nThe ShippingService is the service class of the ShippingController (like the InventoryService being the service class of InventoryController). Since we only see ShippingService in the static analysis, none of the flows covered in the dynamic analysis detected a call to this class. Assuming the coverage of our flows is sufficient, we conclude that the code using this class is “dead code” and should be excluded from (refactored out) of the extracted domain. To do that, select ShippingService (non-exclusive class) and click MARK AS DEAD-CODE. The class is listed under DEAD-CODE section for this domain. When we will extract this service (Refactoring Engine Tutorial), references to this class will be removed.\nOnce the analysis is completed, the static exclusivity of ProductController is 100% - the ShippingRespository is also removed from this domain. The reason for that is that the dependency on ShippingRepository originated from the dependency on Shippingdomain.\nSwitching to view the resources of ProductController and looking at the non-exclusive resources, we see that this domain uses three database tables that are also used by other domains. This is expected, and we don’t need to do anything.\nGo Back to Domains\n"
},
{
	"uri": "/100_architectural-observability/40_observation/5_summary.html",
	"title": "Summary",
	"tags": [],
	"description": "",
	"content": "\nSummary We saw how to setup automatic learning and analysis to continuously observe and detect architectural drifts as the application is changing, and how to update the baseline following the architectural events.\nThis concludes the AO Tutorial. If you are interested to learn about extracting services, continue to the RE Tutorial, if not, just skip to the Cleanup section.\n"
},
{
	"uri": "/100_architectural-observability/30_analysis/6_payment_services.html",
	"title": "Payment Domains",
	"tags": [],
	"description": "",
	"content": "\nPayment Domains Locate the two payment domains: PaymentService and DinersPaymentService. Looking at the spheres in the center pane, they are both being used by ModifyFulfillmentController.\nBoth domains have 50% exclusivity and consist of two classes. The non-exclusive class, AbstractPaymentHttpClient, is shared by both (select one of the domains, click on VIEW next to Dynamic classes, go to the Non-exclusive class, and click Details to see the services that are using it)\nLet\u0026rsquo;s merge these two domains into a single PaymentService. Go back to the domains screen, select the DinersPaymentService sphere, drag it on top of the PaymentService sphere and confirm the merge. Wait for the analysis auto-run to complete.\nThe resulting PaymentService has 100% dynamic exclusivity and 80% static class exclusivity. The non-exclusive classes are Data Transfer Object (DTO) classes which are also being used by the client service ModifyFulfillmentOrder. This is OK as it is part of the interface used between these two domains. "
},
{
	"uri": "/100_architectural-observability/30_analysis/7_shipping_price_modify_fulfillment_controllers.html",
	"title": "Other Services",
	"tags": [],
	"description": "",
	"content": "\nShipping Price Controller and Modifying Fulfillment Controller Select the ShippingPriceController domain – its dynamic class exclusivity is 50%\nView the dynamic classes, the ShippingService is the non-exclusive class.\nClick DETAILS to see what other services use this class (ShippingService) – it is also used by ModifyFulfillmentOrder.\nIn the pop-up, click on ModifyFulfillmentService.getShippingAmout() and move up the call tree to see the call tree as shown here:\nModify Fulfillment Calltree Make ShippingService$$EnhancerBySpringCGLIB.fetchShippingCharges() an entry point of ShippingPriceController - click on the node in the call tree, click MAKE ENTRY POINT, METHOD and select ShippingPriceController domain.\nGo back to the domains view and wait for the analysis to complete. The ShippingPriceController is 100% class exclusive (static and dynamic)\nSelect the ModifyFulfillmentController; it has 100% dynamic class exclusivity and 33% static exclusivity. Review the non-exclusive classes – there are 3 DTO classes and one repository class – this seems fine, and we don’t need to change it.\nReview the left pane of the Analysis Page. The analysis output shows 100% class exclusivity for 100% extracted percentage. This means we have reached a state in which we have eight services that are fully exclusive with respect to the testing flows performed in the Learning phase\nComplete Analysis "
},
{
	"uri": "/100_architectural-observability/30_analysis/8_setting_main_measurement.html",
	"title": "&#34;main&#34; measrement",
	"tags": [],
	"description": "",
	"content": "\nSetting the measurement as \u0026ldquo;main\u0026rdquo; In the Analysis page, click MEASUREMENTS at the bottom and then click SELECT MEASUREMENT. You should see the list of measurements similar to the figure below\nClick on the Star inside the circle (left to the measurement name) to indicate that the current measurement is \u0026ldquo;main\u0026rdquo;. This tagging is useful when working with multiple measurements.\nClick outside the measurement list to close it\nHover over the name of the measurement (top left of the page) and click the pencil icon\nRename the measurement as Baseline 1. This also makes it easier to locate the measurement where the domains are baselines.\n"
},
{
	"uri": "/100_architectural-observability/30_analysis/9_summary.html",
	"title": "Summary",
	"tags": [],
	"description": "",
	"content": "\nSummary We walked through the analysis flows to partition an application into domains, by configuring entry points, merging domains, setting classes as common/non-common/dead-code, and more.\nIn the next part we will see how to setup detect and handle architectural drifts as changes are introduced to the application.\n"
},
{
	"uri": "/10_setup.html",
	"title": "Setup Environment",
	"tags": [],
	"description": "",
	"content": "\nSetup AWS workshop environment In this section, you will create and deploy the necessary AWS services required for this workshop by running a Terraform package.\nThe below diagram depicts the AWS services provisioned the workshop installation package and their usage (the xxx in the names represent a variable string):\nRun the installation package to deploy the Workshop resources Log in to your AWS Account\nOpen the AWS CloudShell (icon is on top right toolbar)\nDownload the workshop installation package from the vFunction portal using the command:\ncurl -o vfunction-workshop-aws-installation.tgz https://portal.vfunction.com/file/023fe68123e76901d11470b8aaefb545/bd14b2b4-52c1-452d-aa6a-2e55520bb1ce/vfunction-workshop-aws-installation.tgz Unpack the installation package tar zxvf vfunction-workshop-aws-installation.tgz Edit the file ./config/installation.yaml file: vim ~/vfunction-workshop/config/installation.yaml Set the region to which the resources will be deployed- you can use any US region, however, if you want to do the Appendix for using AWS Migration Hub Refactor Spaces, make sure that this service is available in the region you choose by searching Refactor Spaces in this region.\nFill in your org_name (must be shorter than 50 chars) and email (e.g., \u0026ldquo;my company\u0026rdquo; as org_name and \u0026ldquo;myname@company.net\u0026rdquo; as email)\nIf you intend to deploy services to EKS, Set use_refactoring to true, otherwise set it to false\nRun the installation and wait for the script to complete\nbash ~/vfunction-workshop/install.sh Setup Remote Desktop to Workshop Windows VM Switch to the EC2 Instances page in the region you set to deploy the workshop\nOpen the EC2 instance with the name starting with workshop-windows (should be in running state) and copy its public IPv4 Address\nOpen your Remote Desktop Protocol (RDP) client and paste the IP as the Host Name or Address\nStart the RDP session. The user name is workshop the password is vFunction2021!\nIf prompted, approve the certificate to access the remote machine\nYou should now see the Windows Desktop running on the Dev VM.\nAccess the Workshop Linux VM Copy the private IP address of the Workshop-Linux VM from the AWS console\nIn the Windows VM (Remote Desktop), run PuTTY (icon is on the desktop)\nIn the PuTTY dialog, enter the private IP address of the Linux VM and click Open\nLogin using the same credentials (login: workshop password:vFunction2021!)\nLogin to the vFunction server The vFunction platform installation was automated by the Workshop Installation package.\nTo login to the platform:\nOpen Chrome in the Windows VM (Remote Desktop)\nType the IP Address of the Linux VM\nLogin with the e-mail you entered in the installation.yaml file. The password is vFunction2021!\nYou should see a screen similar to:\nYou are now ready to proceed to Learning.\n"
},
{
	"uri": "/100_architectural-observability.html",
	"title": "AO Tutorial",
	"tags": [],
	"description": "",
	"content": "\nArchitectural Observability (AO) Tutorial Please complete the Setup Environment section before starting the tutorial and don\u0026rsquo;t forget to Cleanup when you\u0026rsquo;re done with the workshop\nThis is a hands-on tutorial for the vFunction Architectural Observability (AO) module.\nWe will use the Order Management System (OMS) demo application to show how to collect, analyze, gain insights as well as monitor and handle architectural debt and architectural drifts of an application.\nLearning Objectives How to collect data for architectural observability How to identify and address architectural tech debt How to define and baseline domains for the application How to continuously monitor and address architectural drifts Workshop Flow The following flowchart describes the tutorial steps and artifacts of this tutorial.\nThe rounded rectangles represent steps you\u0026rsquo;ll perform (with time estimation), the parallelograms represent artifacts / results (some can be downloaded) and the trapezoid represent an event.\ngraph TD; Learning([\"Learning: Collecting data for architectural observability (10 min.)\"]) Learning --\u003e Measurement[/\"Initial Measurement (click to download)\"/] Measurement --\u003e Analysis([\"Analysis: Get architectural insights and baseline functional domains (45 min.)\"]) Analysis --\u003e BaselineDomains[/\" Baseline measurement\"/] BaselineDomains --\u003e Obs([\"Observation: Setup continuous monitoring of architectural drifts\"]) Obs --\u003e AppMod([\"Deploy and test a new version of the OMS app\"]) AppMod --\u003e NewMeasurement[/\"New measurement + todos\"/] Obs -.-\u003e SchedLearning[/\"Scheduled Learning and Analysis\"\\] SchedLearning -.-\u003e NewMeasurement NewMeasurement --\u003e Review([\"Review and handle todos\"]) click Setup \"./10_setup.html\" click Learning \"./20_learning.html\" click Analysis \"./100_architectural-observability/30_analysis.html\" click Obs \"./100_architectural-observability/40_observation.html\" click ServiceCreation \"./40_servicecreation.html\" click Deployment \"./50_deployment/_index.aws.html\" click Cleanup \"./300_cleanup.html\" click OMSApp \"https://bitbucket.org/vfunction/oms-tutorial/src/mysql/oms-webmvc/\" _blank click Measurement \"https://portal.vfunction.com/file/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1dWlkIjoiNWNhYmNjYTMtNTc5MC00MmY1LWE0ODgtM2RhODZmOGVjYzlmIn0.C--1C7PmFRGUxWxDe-hOtaA9PvmV8NiLLbHrmXmYEr0/5cabcca3-5790-42f5-a488-3da86f8ecc9f/Analysis-Tutorial-Start.zip\" click ServiceSpecs \"https://bitbucket.org/vfunction/oms-tutorial/src/mysql/oms-services/service-specs/\" _blank click Services \"https://bitbucket.org/vfunction/oms-tutorial/src/mysql/oms-services/\" _blank Click on the right arrow or Learning on the left pane to start\n"
},
{
	"uri": "/100_architectural-observability/20_learning.html",
	"title": "Learning",
	"tags": [],
	"description": "",
	"content": "\nLearning In this part, you will run the OMS application and run a script that invokes the OMS APIs.\nWhile the application is running, vFunction collects the data required for analyzing the application.\nThis process is called Learning, and the result is called Measurement.\nIn the vFunction server UI (same screen in the \u0026ldquo;workshop-win\u0026rdquo; VM shown at the end of the setup environment section), click START LEARNING\nWait until vFunction starts collecting data from the controller\nGo to the PuTTY terminal connected to the Workshop Linux VM and do the following commands:\ncd ~/oms-test-script/ for i in `seq 1000`; do ./use-apis.sh ; sleep 0.5; done In the vFunction Server Web UI (switch back to the Windows VM) - you should see the numbers of functions, resources and services in the WebUI go up after some time\nStop the Learning by clicking STOP in vFunction Web UI. We will use a ready measurement to save time\nStop the loop calling use-apis.sh in the \u0026ldquo;workshop-linux\u0026rdquo; VM (press Ctrl+C)\nWe\u0026rsquo;ve seen how to start the Learning process in which vFunction collects data from a running application. The following section covers how to analyze the data and specify services.\nThe OMS application is deployed on a tomcat server on the Linux machine located at /opt/tomcat/latest/. To stop tomcat do: sudo bash /opt/tomcat/apache-tomcat-9.0.56/bin/shutdown.sh (or simply kill the process) To start tomcat do: sudo bash /opt/tomcat/apache-tomcat-9.0.56/bin/startup.sh\n"
},
{
	"uri": "/100_architectural-observability/30_analysis.html",
	"title": "Analysis",
	"tags": [],
	"description": "",
	"content": "\nAnalysis In this part of the tutorial, you will use the data obtained in learning, to refine and specify the domains of the OMS application. The resulting measurement will become the architectural baseline for continuous modernization.\n"
},
{
	"uri": "/100_architectural-observability/40_observation.html",
	"title": "Observation",
	"tags": [],
	"description": "",
	"content": "\nObservation: monitoring and handling architectural drifts Now that we\u0026rsquo;ve specified the various domains, we will setup vFunction to continuously monitor changes in the application to detect architectural drifts and discuss how to handle them.\n"
},
{
	"uri": "/300_cleanup.html",
	"title": "Cleanup",
	"tags": [],
	"description": "",
	"content": "\nCleanup In this section, we will clean up the resources created for this workshop by vfunction-workshop package.\nLog-in to the Workshop Linux VM (using PuTTY in the Workshop Windows VM) and do the following command:\nkubectl delete namespace ingress-nginx Log in to your AWS Account and open the AWS CloudShell (icon is on top right toolbar)\nRun the \u0026ldquo;destroy\u0026rdquo; script to delete all the resources\nbash ~/vfunction-workshop/destroy.sh Wait for the script to complete\nDelete the vfunction-workshop-aws-installation.tgz and the vfunction-workshop-aws-installation directory (under your home directory in the cloud shell)\ncd ~ rm -rf ./vfunction-workshop rm vfunction-workshop-aws-installation.tgz "
},
{
	"uri": "/500_awsrefactorspaces.html",
	"title": "Appendix: AWS Refactor Spaces",
	"tags": [],
	"description": "",
	"content": "\nAppendix: Using AWS Refactor Spaces to \u0026ldquo;Strangle\u0026rdquo; the OMS Application Strangler Pattern is used for incremental migration from a legacy application to services by replacing existing functionalities provided by the original application with functionalities provided by the services.\nAWS Migration Hub Refactor Spaces is a tool that allows one to automate and manage this incremental migration by creating and configuring an elastic load balancer in AWS that routes API calls either to the original application or to the relevant service.\nIn this appendix, you will use Refactor Spaces to strangle the example OMS application after it was refactored in vFunction, and three of the services were deployed to EKS.\nPrecondition: Test that the original application works via the public IP address In the Windows VM, open Postman\nImport to postman the file: C:\\vFunctionLab\\oms-tutorial\\oms-webmvc\\script\\OMS.postman_collection.json\nIn the OMS Collection, open Create Order and change localhost with the public IP of the Linux machine\nSend the request and ensure you get a correct response\nCreate Environment Open the AWS console of one of the EC2 instances of the workshop VMs and copy the VPC ID for the next steps\nSearch and open the Refactor Spaces feature of AWS Migration Hub (same region as the workshop)\nOn the left pane, click on Environments and then click Create environment in the main pane\nIn the Create environment form, set the Environment name to Workshop-OMS and hit Next\nIn the Create application form, enter Order Management System for the application name\nSelect the VPC ID of the workshop VPC\nClick Next in the Share environment - optional\nReview and Create the environment\nCreate Service with Default Route After the environment on the Environments page is shown to be in the Healthy state, click on the environment and then on the Order Management System application.\nCreate a service based to which the messages will be routed to by default:\na. Set the service name to OMS-Monolith\nb. Set the VPC to the VPC of the workshop (as before)\nc. The default route Endpoint should redirect the traffic to the original OMS application running on the Linux machine, so it should be in the form: http://[Linux VM public IP]:8080/oms-0.0.1-SNAPSHOT/service\nd. Check the checkbox for the default route\nThe application screen should look similar to:\nCreate Service for Order Controller In the Order Management Application Screen, click Create Service\nSet the Service name to order-controller\nSet the VPC to the VPC of the workshop (as before)\nSet the endpoint to the endpoint of order controller in EKS - the endpoints used in the Deployment section (e.g., http://a607a6d36a4cf497b86eeedc239dcb91-fe444a9b3f77e2b5.elb.us-west-2.amazonaws.com/order-controller)\nClick Create service\nClick Create Route and set the Source path to /order-controller, then click Create route. The example form is below: The application screen should now look similar to:\nTest Copy the Proxy URL of the Order Management System application in Refactor Spaces and use it to call APIs by replacing it in Postman\nExample: For a Proxy URL https://gv4qtsettk.execute-api.us-west-2.amazonaws.com/prod\nhttps://gv4qtsettk.execute-api.us-west-2.amazonaws.com/prod/order-controller/order/multi to create multiple order by routing the calls to EKS\nhttps://gv4qtsettk.execute-api.us-west-2.amazonaws.com/prod/inventory sends the API call to the original application to create an inventory item\nCleanup Before proceeding to the Cleanup section, make sure to delete the Refactoring Spaces environment. You will need first to delete the routes and services, then the application and finally the environment.\n"
},
{
	"uri": "/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]